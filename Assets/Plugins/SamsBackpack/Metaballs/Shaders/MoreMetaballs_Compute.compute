//Metaballs by Sam's Backpack is licensed under CC BY-SA 4.0 (http://creativecommons.org/licenses/by-sa/4.0/)
//Source page of the project : https://niwala.itch.io/metaballs

#pragma kernel Clear
#pragma kernel AsignAreas
#pragma kernel Flatten
#pragma kernel JumpFlooding
#pragma kernel Render
#pragma kernel RenderData


//#define RenderTexBorders	//Remove the comment to add borders on the edges of the renderTexture.
#define MaxValue 999


//Structs
struct Emitter
{
    float3 position;
    float radius;
    int channel;
};

struct Area
{
	float distance;
	float2 coords;
	int id;
};

//Buffers
StructuredBuffer<Emitter> _Emitters;
StructuredBuffer<float4> _Colors;
RWStructuredBuffer<float> _Distances;

//
StructuredBuffer<Area> _AreasRead;
RWStructuredBuffer<Area> _AreasWrite;

float _Metaball_Smooth;
int _EmitterCount;
int _ChannelCount;
float2 _InvMapSize;
RWTexture2D<float4> _Result;
Texture2D<float> _BorderGradient;
int _MapSize;
int _JumpFloodingStepSize;
float _BorderPower;
SamplerState linear_clamp_sampler;
int _BorderMode;	//0 = NoBorder, 1 = GroupAllAreas, 2 = SplitAreas


//Exponential smooth min Inigo Quilez - https://iquilezles.org/articles/smin/
float smin(float a, float b, float k)
{
    float res = exp2(-k * a) + exp2(-k * b);
    return -log2(res) / k;
}

[numthreads(8, 8, 8)]
void Clear(uint3 id : SV_DispatchThreadID)
{
    int i = id.z * _MapSize * _MapSize + id.x * _MapSize + id.y;
    _Distances[i] = 2;
}

[numthreads(8,8,1)]
void AsignAreas (int3 id : SV_DispatchThreadID)
{
    float2 position = id.xy * _InvMapSize * 2.0 - 1.0;

    for (int j = 0; j < _EmitterCount; j++)
    {
        Emitter emitter = _Emitters[j];
		float dist = distance(position, emitter.position.xz);
        float factor = dist - emitter.radius;
        int i = emitter.channel * _MapSize * _MapSize + id.x * _MapSize + id.y;
        _Distances[i] = smin(_Distances[i], factor, _Metaball_Smooth);
    }
}

[numthreads(8, 8, 1)]
void Flatten(int3 id : SV_DispatchThreadID)
{
    float distance = 1;
    int channel = -1;
	int i = id.x * _MapSize + id.y;

    for (int j = 0; j < _ChannelCount; j++)
    {
        int i = j * _MapSize * _MapSize + id.x * _MapSize + id.y;
        if (_Distances[i] < distance)
        {
            distance = _Distances[i];
            channel = j;
		}
    }
    
	Area area;
	area.id = channel;
    if (distance < 0)
	{
		area.coords = MaxValue;
		area.distance = MaxValue;
	}
    else
	{
		area.coords = id.xy * _InvMapSize;
		area.distance = 0.0;
	}
	_AreasWrite[i] = area;
}


[numthreads(8, 8, 1)]
void JumpFlooding(int3 id : SV_DispatchThreadID)
{
	int jumSize = _JumpFloodingStepSize;

	int2 pos = id.xy;
	int i = id.x * _MapSize + id.y;
	Area current = _AreasRead[i];
	float2 center = float2(pos * _InvMapSize);
	current.distance = distance(current.coords, center);

    
	if (current.distance < 0)
		return;

	for (int y = -1; y <= 1; ++y)
	{
		int posY = pos.y + y * jumSize;
		#ifndef RenderTexBorders 
		if (posY < 0 || posY >= _MapSize)
			continue;
		#endif

		for (int x = -1; x <= 1; ++x)
		{
			int posX = pos.x + x * jumSize;
			#ifndef RenderTexBorders 
			if (posX < 0 || posX >= _MapSize)
				continue;
			#endif
        
        	Area neighbor = _AreasRead[posX * _MapSize + posY];
			float d = distance(neighbor.coords, center);
            
			//Add borders between areas
			if (_BorderMode == 2 && neighbor.id != current.id)
			{
				neighbor.coords = float2(posX, posY) * _InvMapSize;
				d = 0;
			}
			
			//Add border on the edge of the render texture
			#ifdef RenderTexBorders
			if (min(posX, posY) < 0 || max(posX, posY) >= _MapSize)
			{
				neighbor.coords = float2(posX, posY) * _InvMapSize;
				//d = 0;
			}
			#endif

			
			if (d < current.distance)
			{
				current.distance = d;
				current.coords = neighbor.coords;
			}
		}
	}
    
	_AreasWrite[i] = current;
}

[numthreads(8, 8, 1)]
void Render(int3 id : SV_DispatchThreadID)
{
	//Get area color & shape
	Area area = _AreasRead[id.x * _MapSize + id.y];
	float4 color = _Colors[area.id];
	float alpha = step(0.0001, area.distance);
	color.a *= alpha;
        
	//Add borders
	if (_BorderMode != 0)
	{
		float borders = _BorderGradient.SampleLevel(linear_clamp_sampler, pow(abs(area.distance), _BorderPower), 0).x;
		color.a *= borders;
	}

	//Return result
	_Result[id.xy] = color;
}

[numthreads(8, 8, 1)]
void RenderData(int3 id : SV_DispatchThreadID)
{
	Area area = _AreasRead[id.x * _MapSize + id.y];
	_Result[id.xy] = float4(area.id, area.distance, area.coords);
}